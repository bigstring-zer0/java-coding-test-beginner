package array;

public class 에라토스테네스_체 {
    public static int solution(int n) {
        int answer = 0;
        // n까지의 수에 대한 소수 여부를 기록해야 하므로 인덱스는 0부터 시작하는것을 유의하여 check 배열의 크기를 n+1로 생성한다.
        // 예를 들어 20까지의 소수 여부를 계산하려면 크기를 21로 생성해야 인덱스가 20까지 생겨서 20이 소수인지의 여부를 기록할 수 있다.
        int[] check = new int[n + 1];

        // 이중 루프를 활용하긴 하지만 j를 i만큼 증가시키면서 j루프를 통해서 check[j]에다가 1로 기록한다.
        //이것의 의미는 j는 1과 j 자기 자신을 제외한 i라는 원소를 가지고 있는 정수라는 의미이므로 check 배열에다가 소수가 아니다 라는 의미로 1을 기록한다.
        //이렇게 이중 루프를 돌며 check 배열에다가 소수가 아닌 수를 1로 기록하며 탐색을 하다보면 이중 루프를 활용하긴 하지만 시간초과가 발생하지않고 정수 N까지의 소수의 갯수를 계산할 수 있다.
        // 이중 루프를 활용한 에라토스테네스의 체를 활용한 풀이법
        // 1은 소수가 아님을 알기 때문에 정수 2부터 소수 여부 체크
        for (int i = 2; i <= n; i++) {
            // 만약 i가 0이라면 i 보다 작은 수중에서는 i를 배수로 가지는 소수가 없다는 의미다.
            if (check[i] == 0) {
                // 소수를 찾았으므로 answer값 1 증가.
                answer++;
                // i가 소수임이 밝혀졌으므로 루프를 활용하여 check 배열에 i의 배수는 소수가 아님을 기록
                // j는 i부터 시작해서 n까지 반복하며 i의 배수를 가지는 정수는 소수가 아님을 체크하기 위하여
                // 한번 루프를 반복할때 증가 값은 i만큼 증가한다.
                for (int j = i; j <= n; j += i) {
                    // 소수 i의 배수인 N까지의 모든 정수값은 소수 i를 약수로 가지므로
                    // 정수가 아님을 의미하는 1을 기록
                    check[j] = 1;
                }
            }
        }

        return answer;
    }

    public static void main(String[] args) {
        System.out.println(solution(10));
    }
}
